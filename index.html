<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Face Overlay Mirror</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .mirror-container {
            position: relative;
            width: 100%;
            flex: 1;
            overflow: hidden;
            background: #000;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror for selfie view */
        }

        .overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .face-overlay {
            position: absolute;
            transform-origin: center center;
            pointer-events: none;
            will-change: transform;
            /* Hide until positioned */
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .face-overlay.visible {
            opacity: 1;
        }

        .face-overlay img {
            display: block;
            width: 100%;
            height: auto;
        }

        .controls {
            padding: 12px;
            background: #16213e;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .control-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            background: #0f3460;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            background: #e94560;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #startBtn {
            background: #e94560;
            font-weight: 600;
        }

        .status {
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: #0f0f1a;
        }

        .upload-section {
            padding: 12px;
            background: #1a1a2e;
            border-top: 1px solid #333;
        }

        .upload-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .upload-label {
            font-size: 12px;
            color: #aaa;
        }

        #fileInput {
            display: none;
        }

        .upload-btn {
            padding: 8px 14px;
            background: #0f3460;
            border: 1px dashed #4a5568;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            cursor: pointer;
        }

        select {
            padding: 8px 12px;
            background: #0f3460;
            border: 1px solid #4a5568;
            border-radius: 8px;
            color: white;
            font-size: 12px;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="mirror-container">
            <video id="video" autoplay playsinline muted></video>
            <div class="overlay-layer" id="overlayLayer">
                <!-- Dynamic overlay elements will be added here -->
            </div>
            <div class="loading-overlay" id="loadingOverlay">
                <div class="spinner"></div>
                <div class="loading-text" id="loadingText">Initializing...</div>
            </div>
        </div>

        <div class="controls" id="controls">
            <button class="control-btn" id="startBtn">Start Camera</button>
        </div>

        <div class="upload-section">
            <div class="upload-row">
                <label class="upload-btn" for="fileInput">Upload Overlay</label>
                <input type="file" id="fileInput" accept="image/png,image/svg+xml">
                <select id="anchorType">
                    <option value="eyes">Eyes (glasses/mask)</option>
                    <option value="mouth">Mouth (moustache)</option>
                    <option value="nose">Nose (clown nose)</option>
                    <option value="forehead">Forehead (hair/hat)</option>
                    <option value="fullface">Full Face</option>
                </select>
            </div>
        </div>

        <div class="status" id="status">Ready - Tap "Start Camera" to begin</div>
    </div>

    <!-- MediaPipe Face Landmarker -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/vision_bundle.min.js" crossorigin="anonymous"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================

        // Overlay configuration schema
        const OVERLAY_CONFIGS = {
            eyes: {
                // For glasses, eye masks, domino masks
                anchorLandmarks: { left: 33, right: 263 }, // outer eye corners
                offsetY: 0,        // offset in eye-distance units (negative = up)
                offsetX: 0,
                baseScale: 2.5,    // scale multiplier relative to eye distance
                transformOrigin: 'center center'
            },
            mouth: {
                // For moustaches, lip overlays
                anchorLandmarks: { left: 61, right: 291 }, // mouth corners
                offsetY: -0.1,     // slight upward offset
                offsetX: 0,
                baseScale: 1.8,
                transformOrigin: 'center center'
            },
            forehead: {
                // For hair, hats, crowns
                anchorLandmarks: { left: 33, right: 263 }, // use eyes as reference
                offsetY: -1.5,     // move up significantly
                offsetX: 0,
                baseScale: 3.0,
                transformOrigin: 'center bottom' // pivot from bottom of hair
            },
            fullface: {
                // For full face masks
                anchorLandmarks: { left: 33, right: 263 },
                offsetY: 0.5,      // center on face
                offsetX: 0,
                baseScale: 4.0,
                transformOrigin: 'center center'
            },
            nose: {
                // For clown noses, animal snouts
                anchorLandmarks: { left: 33, right: 263 }, // use eyes as reference
                offsetY: 0.6,      // move down to nose position
                offsetX: 0,
                baseScale: 0.8,
                transformOrigin: 'center center'
            }
        };

        // Smoothing factor (0-1, lower = smoother but more lag)
        const SMOOTHING_ALPHA = 0.3;

        // ============================================
        // STATE
        // ============================================

        let faceLandmarker = null;
        let video = null;
        let isRunning = false;
        let animationId = null;
        let videoWidth = 0;
        let videoHeight = 0;

        // Active overlays
        const activeOverlays = new Map(); // id -> { element, config, smoothed }

        // Smoothed values per overlay
        function createSmoothedState() {
            return {
                x: null,
                y: null,
                rotation: null,
                scale: null
            };
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        async function initializeFaceLandmarker() {
            updateStatus('Loading face detection model...');

            const { FaceLandmarker, FilesetResolver } = await window.vision;

            const filesetResolver = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                minFaceDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            updateStatus('Model loaded - Ready to start');
            document.getElementById('startBtn').disabled = false;
            hideLoading();
        }

        async function startCamera() {
            try {
                updateStatus('Requesting camera access...');
                showLoading('Accessing camera...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                });

                video = document.getElementById('video');
                video.srcObject = stream;

                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        videoWidth = video.videoWidth;
                        videoHeight = video.videoHeight;
                        resolve();
                    };
                });

                await video.play();

                hideLoading();
                isRunning = true;
                document.getElementById('startBtn').textContent = 'Stop Camera';
                document.getElementById('startBtn').classList.add('active');
                updateStatus('Camera active - Face tracking running');

                // Start detection loop
                detectFaces();

            } catch (error) {
                console.error('Camera error:', error);
                updateStatus('Camera error: ' + error.message);
                hideLoading();
            }
        }

        function stopCamera() {
            isRunning = false;

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }

            // Hide all overlays
            activeOverlays.forEach(overlay => {
                overlay.element.classList.remove('visible');
            });

            document.getElementById('startBtn').textContent = 'Start Camera';
            document.getElementById('startBtn').classList.remove('active');
            updateStatus('Camera stopped');
        }

        // ============================================
        // FACE DETECTION LOOP
        // ============================================

        function detectFaces() {
            if (!isRunning || !faceLandmarker || !video) return;

            const startTime = performance.now();

            try {
                const results = faceLandmarker.detectForVideo(video, startTime);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    updateOverlays(landmarks);
                } else {
                    // No face detected - hide overlays
                    activeOverlays.forEach(overlay => {
                        overlay.element.classList.remove('visible');
                    });
                }
            } catch (error) {
                console.error('Detection error:', error);
            }

            animationId = requestAnimationFrame(detectFaces);
        }

        // ============================================
        // OVERLAY TRANSFORM CALCULATIONS
        // ============================================

        function updateOverlays(landmarks) {
            const containerRect = document.querySelector('.mirror-container').getBoundingClientRect();

            activeOverlays.forEach((overlay, id) => {
                const config = overlay.config;
                const anchorConfig = OVERLAY_CONFIGS[config.anchorType];

                // Get anchor landmarks
                const leftLandmark = landmarks[anchorConfig.anchorLandmarks.left];
                const rightLandmark = landmarks[anchorConfig.anchorLandmarks.right];

                if (!leftLandmark || !rightLandmark) return;

                // Convert normalized coordinates to pixel coordinates
                // Note: landmarks are in normalized [0,1] space
                // We need to mirror X because video is mirrored with CSS
                const leftX = (1 - leftLandmark.x) * containerRect.width;
                const leftY = leftLandmark.y * containerRect.height;
                const rightX = (1 - rightLandmark.x) * containerRect.width;
                const rightY = rightLandmark.y * containerRect.height;

                // Calculate center point
                let centerX = (leftX + rightX) / 2;
                let centerY = (leftY + rightY) / 2;

                // Calculate distance (for scaling)
                const dx = rightX - leftX;
                const dy = rightY - leftY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Calculate rotation (roll) from eye line
                // Note: atan2 gives angle, we negate because of mirrored view
                const rotation = Math.atan2(dy, dx);

                // Calculate scale based on distance
                const referenceDistance = 100; // baseline eye distance in pixels
                const scale = (distance / referenceDistance) * anchorConfig.baseScale * (config.scaleMultiplier || 1);

                // Apply offset (in eye-distance units)
                const offsetX = (anchorConfig.offsetX + (config.offsetX || 0)) * distance;
                const offsetY = (anchorConfig.offsetY + (config.offsetY || 0)) * distance;

                // Rotate offset by current rotation
                const cosR = Math.cos(rotation);
                const sinR = Math.sin(rotation);
                centerX += offsetX * cosR - offsetY * sinR;
                centerY += offsetX * sinR + offsetY * cosR;

                // Apply smoothing
                const smoothed = overlay.smoothed;
                if (smoothed.x === null) {
                    // First frame - initialize without smoothing
                    smoothed.x = centerX;
                    smoothed.y = centerY;
                    smoothed.rotation = rotation;
                    smoothed.scale = scale;
                } else {
                    // Lerp towards new values
                    smoothed.x = lerp(smoothed.x, centerX, SMOOTHING_ALPHA);
                    smoothed.y = lerp(smoothed.y, centerY, SMOOTHING_ALPHA);
                    smoothed.rotation = lerpAngle(smoothed.rotation, rotation, SMOOTHING_ALPHA);
                    smoothed.scale = lerp(smoothed.scale, scale, SMOOTHING_ALPHA);
                }

                // Apply transform to element
                const element = overlay.element;
                const originX = element.offsetWidth / 2;
                const originY = element.offsetHeight / 2;

                // Build transform
                // We translate to position, then rotate, then scale
                // The element should be centered on the anchor point
                element.style.transform = `
                    translate(${smoothed.x - originX}px, ${smoothed.y - originY}px)
                    rotate(${smoothed.rotation}rad)
                    scale(${smoothed.scale})
                `;
                element.style.transformOrigin = anchorConfig.transformOrigin || 'center center';
                element.classList.add('visible');
            });
        }

        // Linear interpolation
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // Angle interpolation (handles wrap-around)
        function lerpAngle(a, b, t) {
            let diff = b - a;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            return a + diff * t;
        }

        // ============================================
        // OVERLAY MANAGEMENT
        // ============================================

        function addOverlay(imageUrl, anchorType, options = {}) {
            const id = 'overlay-' + Date.now();

            const element = document.createElement('div');
            element.className = 'face-overlay';
            element.id = id;

            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = 'Face overlay';
            element.appendChild(img);

            // Wait for image to load to get dimensions
            img.onload = () => {
                // Set a base size (will be scaled by transform)
                const baseWidth = 100; // pixels at scale 1
                element.style.width = baseWidth + 'px';
            };

            document.getElementById('overlayLayer').appendChild(element);

            const config = {
                anchorType: anchorType,
                scaleMultiplier: options.scaleMultiplier || 1,
                offsetX: options.offsetX || 0,
                offsetY: options.offsetY || 0
            };

            activeOverlays.set(id, {
                element: element,
                config: config,
                smoothed: createSmoothedState()
            });

            // Add control button
            addOverlayButton(id, anchorType);

            return id;
        }

        function removeOverlay(id) {
            const overlay = activeOverlays.get(id);
            if (overlay) {
                overlay.element.remove();
                activeOverlays.delete(id);
            }

            // Remove button
            const btn = document.getElementById('btn-' + id);
            if (btn) btn.remove();
        }

        function addOverlayButton(id, type) {
            const controls = document.getElementById('controls');
            const btn = document.createElement('button');
            btn.className = 'control-btn active';
            btn.id = 'btn-' + id;
            btn.textContent = type.charAt(0).toUpperCase() + type.slice(1) + ' X';
            btn.onclick = () => removeOverlay(id);
            controls.appendChild(btn);
        }

        // ============================================
        // FILE UPLOAD HANDLING
        // ============================================

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const anchorType = document.getElementById('anchorType').value;

            const reader = new FileReader();
            reader.onload = (event) => {
                addOverlay(event.target.result, anchorType);
                updateStatus(`Added ${anchorType} overlay`);
            };
            reader.readAsDataURL(file);

            // Reset input so same file can be uploaded again
            e.target.value = '';
        });

        // ============================================
        // UI HELPERS
        // ============================================

        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text || 'Loading...';
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        document.getElementById('startBtn').addEventListener('click', () => {
            if (isRunning) {
                stopCamera();
            } else {
                startCamera();
            }
        });

        // ============================================
        // DEMO OVERLAYS
        // ============================================

        // Sample overlay definitions
        const SAMPLE_OVERLAYS = [
            {
                name: 'Glasses',
                file: 'overlays/star-glasses.svg',
                anchor: 'eyes',
                options: { scaleMultiplier: 1.0 }
            },
            {
                name: 'Hero Mask',
                file: 'overlays/superhero-mask.svg',
                anchor: 'eyes',
                options: { scaleMultiplier: 1.1, offsetY: 0.05 }
            },
            {
                name: 'Cat Ears',
                file: 'overlays/cat-ears.svg',
                anchor: 'forehead',
                options: { scaleMultiplier: 1.2, offsetY: -0.3 }
            },
            {
                name: 'Crown',
                file: 'overlays/crown.svg',
                anchor: 'forehead',
                options: { scaleMultiplier: 1.0 }
            },
            {
                name: 'Moustache',
                file: 'overlays/handlebar-moustache.svg',
                anchor: 'mouth',
                options: { scaleMultiplier: 1.0 }
            },
            {
                name: 'Clown Nose',
                file: 'overlays/clown-nose.svg',
                anchor: 'nose',
                options: { scaleMultiplier: 1.0 }
            },
            {
                name: 'Dog Face',
                file: 'overlays/dog-face.svg',
                anchor: 'fullface',
                options: { scaleMultiplier: 0.9, offsetY: 0.1 }
            }
        ];

        function addDemoOverlays() {
            const controls = document.getElementById('controls');

            // Add a separator
            const separator = document.createElement('div');
            separator.style.cssText = 'width:100%;height:1px;background:#333;margin:4px 0;';
            controls.appendChild(separator);

            // Add label
            const label = document.createElement('span');
            label.textContent = 'Samples:';
            label.style.cssText = 'font-size:11px;color:#666;margin-right:4px;';
            controls.appendChild(label);

            // Add buttons for each sample overlay
            SAMPLE_OVERLAYS.forEach(overlay => {
                const btn = document.createElement('button');
                btn.className = 'control-btn';
                btn.textContent = overlay.name;
                btn.style.fontSize = '12px';
                btn.style.padding = '6px 10px';
                btn.onclick = () => {
                    addOverlay(overlay.file, overlay.anchor, overlay.options);
                    updateStatus(`Added ${overlay.name}`);
                };
                controls.appendChild(btn);
            });

            // Add clear all button
            const clearBtn = document.createElement('button');
            clearBtn.className = 'control-btn';
            clearBtn.textContent = 'Clear All';
            clearBtn.style.cssText = 'font-size:12px;padding:6px 10px;background:#8b0000;';
            clearBtn.onclick = () => {
                const ids = Array.from(activeOverlays.keys());
                ids.forEach(id => removeOverlay(id));
                updateStatus('All overlays removed');
            };
            controls.appendChild(clearBtn);
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        window.addEventListener('load', async () => {
            document.getElementById('startBtn').disabled = true;
            showLoading('Loading face detection...');

            try {
                await initializeFaceLandmarker();
                addDemoOverlays();
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('Error loading: ' + error.message);
                hideLoading();
            }
        });

        // Handle visibility change (pause when tab hidden)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isRunning) {
                // Optionally pause detection when hidden
            }
        });
    </script>
</body>
</html>
