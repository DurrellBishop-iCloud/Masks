<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Face Mask Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Tab navigation */
        .tabs {
            display: flex;
            background: #0f0f1a;
        }

        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #16213e;
            border: none;
            color: #888;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab.active {
            background: #e94560;
            color: white;
        }

        /* View containers */
        .view {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .view.active {
            display: flex;
        }

        .camera-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            overflow: hidden;
            background: #000;
        }

        #video, #captureVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #video {
            transform: scaleX(-1);
            -webkit-transform: scaleX(-1);
        }

        #debugCanvas, #captureCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #previewCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: crosshair;
        }

        /* Checkerboard background for transparency preview */
        .transparency-bg {
            background-image:
                linear-gradient(45deg, #444 25%, transparent 25%),
                linear-gradient(-45deg, #444 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #444 75%),
                linear-gradient(-45deg, transparent 75%, #444 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #333;
        }

        .controls {
            padding: 12px;
            background: #16213e;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .control-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            background: #0f3460;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            background: #e94560;
        }

        .control-btn.primary {
            background: #e94560;
            font-weight: 600;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.success {
            background: #27ae60;
        }

        .status {
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: #0f0f1a;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 14px;
            color: #888;
        }

        /* Slider controls */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: #0f0f1a;
        }

        .slider-row label {
            font-size: 12px;
            color: #888;
            min-width: 80px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            color: #e94560;
            min-width: 30px;
            text-align: right;
        }

        /* Preview states */
        .preview-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .hidden {
            display: none !important;
        }

        /* Saved masks gallery */
        .gallery {
            display: flex;
            gap: 8px;
            padding: 8px;
            overflow-x: auto;
            background: #0f0f1a;
        }

        .gallery-item {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            flex-shrink: 0;
        }

        .gallery-item.selected {
            border-color: #e94560;
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" data-view="track">Face Track</button>
            <button class="tab" data-view="capture">Create Mask</button>
        </div>

        <!-- Face Tracking View -->
        <div class="view active" id="trackView">
            <div class="camera-container">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="debugCanvas"></canvas>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text" id="loadingText">Initializing...</div>
                </div>
            </div>
            <div class="controls">
                <button class="control-btn primary" id="startBtn">Start Camera</button>
            </div>
            <div class="status" id="trackStatus">Ready - Tap "Start Camera" to begin</div>
        </div>

        <!-- Capture/Create Mask View -->
        <div class="view" id="captureView">
            <!-- Camera state -->
            <div id="captureCamera" class="camera-container">
                <video id="captureVideo" autoplay playsinline muted></video>
            </div>

            <!-- Preview state (after photo taken) -->
            <div id="capturePreview" class="preview-container transparency-bg hidden">
                <canvas id="previewCanvas"></canvas>
            </div>

            <div class="slider-row" id="toleranceRow">
                <label>Tolerance:</label>
                <input type="range" id="toleranceSlider" min="10" max="150" value="60">
                <span class="slider-value" id="toleranceValue">60</span>
            </div>

            <div class="controls" id="captureControls">
                <button class="control-btn primary" id="takePhotoBtn">Take Photo</button>
            </div>

            <div class="controls hidden" id="editControls">
                <button class="control-btn" id="retakeBtn">Retake</button>
                <button class="control-btn success" id="saveMaskBtn">Save Mask</button>
            </div>

            <div class="status" id="captureStatus">Point camera at your drawing and tap "Take Photo"</div>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/+esm';

        // ============================================
        // LANDMARK INDICES
        // ============================================

        const LEFT_EYE_CENTER = 468;
        const RIGHT_EYE_CENTER = 473;
        const LEFT_EYE_INNER = 133;
        const LEFT_EYE_OUTER = 33;
        const RIGHT_EYE_INNER = 362;
        const RIGHT_EYE_OUTER = 263;
        const MOUTH_LEFT = 61;
        const MOUTH_RIGHT = 291;
        const UPPER_LIP_TOP = 13;
        const LOWER_LIP_BOTTOM = 14;
        const FACE_OVAL = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];
        const LEFT_EAR_TOP = 127;
        const LEFT_EAR_BOTTOM = 234;
        const RIGHT_EAR_TOP = 356;
        const RIGHT_EAR_BOTTOM = 454;

        // ============================================
        // STATE
        // ============================================

        let faceLandmarker = null;
        let trackVideo = null;
        let trackCanvas = null;
        let trackCtx = null;
        let isTracking = false;
        let trackAnimationId = null;

        let captureVideo = null;
        let captureStream = null;
        let previewCanvas = null;
        let previewCtx = null;
        let originalImageData = null;
        let currentView = 'track';

        // Saved masks
        const savedMasks = [];

        // ============================================
        // TAB NAVIGATION
        // ============================================

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const viewId = tab.dataset.view;
                switchView(viewId);
            });
        });

        function switchView(viewId) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-view="${viewId}"]`).classList.add('active');

            // Update views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId + 'View').classList.add('active');

            currentView = viewId;

            // Handle camera switching
            if (viewId === 'capture') {
                stopTracking();
                startCaptureCamera();
            } else {
                stopCaptureCamera();
            }
        }

        // ============================================
        // FACE TRACKING (same as before)
        // ============================================

        async function initializeFaceLandmarker() {
            updateStatus('track', 'Loading face detection model...');

            const filesetResolver = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                minFaceDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                outputFaceBlendshapes: false,
                outputFacialTransformationMatrixes: false
            });

            updateStatus('track', 'Model loaded - Ready to start');
            document.getElementById('startBtn').disabled = false;
            hideLoading();
        }

        async function startTracking() {
            try {
                updateStatus('track', 'Requesting camera access...');
                showLoading('Accessing camera...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: false
                });

                trackVideo = document.getElementById('video');
                trackVideo.srcObject = stream;
                await new Promise(r => trackVideo.onloadedmetadata = r);
                await trackVideo.play();

                trackCanvas = document.getElementById('debugCanvas');
                trackCtx = trackCanvas.getContext('2d');
                resizeTrackCanvas();

                hideLoading();
                isTracking = true;
                document.getElementById('startBtn').textContent = 'Stop Camera';
                document.getElementById('startBtn').classList.add('active');
                updateStatus('track', 'Face tracking active');

                detectFaces();
            } catch (error) {
                console.error('Camera error:', error);
                updateStatus('track', 'Camera error: ' + error.message);
                hideLoading();
            }
        }

        function stopTracking() {
            isTracking = false;
            if (trackAnimationId) {
                cancelAnimationFrame(trackAnimationId);
                trackAnimationId = null;
            }
            if (trackVideo && trackVideo.srcObject) {
                trackVideo.srcObject.getTracks().forEach(t => t.stop());
                trackVideo.srcObject = null;
            }
            if (trackCtx) {
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);
            }
            document.getElementById('startBtn').textContent = 'Start Camera';
            document.getElementById('startBtn').classList.remove('active');
            updateStatus('track', 'Camera stopped');
        }

        function resizeTrackCanvas() {
            const container = trackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            trackCanvas.width = rect.width;
            trackCanvas.height = rect.height;
        }

        function detectFaces() {
            if (!isTracking || !faceLandmarker || !trackVideo) return;

            try {
                const results = faceLandmarker.detectForVideo(trackVideo, performance.now());
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    drawDebugOverlay(results.faceLandmarks[0]);
                }
            } catch (error) {
                console.error('Detection error:', error);
            }

            trackAnimationId = requestAnimationFrame(detectFaces);
        }

        function drawDebugOverlay(landmarks) {
            const w = trackCanvas.width;
            const h = trackCanvas.height;
            const toCanvas = (idx) => ({
                x: (1 - landmarks[idx].x) * w,
                y: landmarks[idx].y * h
            });

            // Face oval
            trackCtx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            trackCtx.lineWidth = 2;
            trackCtx.beginPath();
            const first = toCanvas(FACE_OVAL[0]);
            trackCtx.moveTo(first.x, first.y);
            for (let i = 1; i < FACE_OVAL.length; i++) {
                const pt = toCanvas(FACE_OVAL[i]);
                trackCtx.lineTo(pt.x, pt.y);
            }
            trackCtx.closePath();
            trackCtx.stroke();

            // Eyes
            trackCtx.fillStyle = '#00ff00';
            [LEFT_EYE_CENTER, RIGHT_EYE_CENTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                trackCtx.fill();
            });

            trackCtx.fillStyle = '#ffff00';
            [LEFT_EYE_INNER, LEFT_EYE_OUTER, RIGHT_EYE_INNER, RIGHT_EYE_OUTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Mouth
            const mL = toCanvas(MOUTH_LEFT);
            const mR = toCanvas(MOUTH_RIGHT);
            trackCtx.strokeStyle = '#ff00ff';
            trackCtx.lineWidth = 3;
            trackCtx.beginPath();
            trackCtx.moveTo(mL.x, mL.y);
            trackCtx.lineTo(mR.x, mR.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ff00ff';
            [mL, mR].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            const uL = toCanvas(UPPER_LIP_TOP);
            const lL = toCanvas(LOWER_LIP_BOTTOM);
            trackCtx.fillStyle = '#ff6600';
            [uL, lL].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Ears
            trackCtx.strokeStyle = '#ffff00';
            trackCtx.lineWidth = 3;
            const leT = toCanvas(LEFT_EAR_TOP);
            const leB = toCanvas(LEFT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(leT.x, leT.y);
            trackCtx.lineTo(leB.x, leB.y);
            trackCtx.stroke();

            const reT = toCanvas(RIGHT_EAR_TOP);
            const reB = toCanvas(RIGHT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(reT.x, reT.y);
            trackCtx.lineTo(reB.x, reB.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ffff00';
            [leT, leB, reT, reB].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });
        }

        // ============================================
        // CAPTURE / CREATE MASK
        // ============================================

        async function startCaptureCamera() {
            try {
                updateStatus('capture', 'Starting camera...');

                captureStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                    audio: false
                });

                captureVideo = document.getElementById('captureVideo');
                captureVideo.srcObject = captureStream;
                await new Promise(r => captureVideo.onloadedmetadata = r);
                await captureVideo.play();

                // Show camera, hide preview
                document.getElementById('captureCamera').classList.remove('hidden');
                document.getElementById('capturePreview').classList.add('hidden');
                document.getElementById('captureControls').classList.remove('hidden');
                document.getElementById('editControls').classList.add('hidden');
                document.getElementById('toleranceRow').classList.add('hidden');

                updateStatus('capture', 'Point camera at your drawing and tap "Take Photo"');
            } catch (error) {
                console.error('Capture camera error:', error);
                updateStatus('capture', 'Camera error: ' + error.message);
            }
        }

        function stopCaptureCamera() {
            if (captureStream) {
                captureStream.getTracks().forEach(t => t.stop());
                captureStream = null;
            }
            if (captureVideo) {
                captureVideo.srcObject = null;
            }
        }

        function takePhoto() {
            if (!captureVideo) return;

            previewCanvas = document.getElementById('previewCanvas');
            previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });

            // Set canvas to video dimensions
            previewCanvas.width = captureVideo.videoWidth;
            previewCanvas.height = captureVideo.videoHeight;

            // Draw video frame to canvas
            previewCtx.drawImage(captureVideo, 0, 0);

            // Store original image data
            originalImageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            // Analyze paper color from edges
            analyzePaper();

            // Stop camera
            stopCaptureCamera();

            // Show preview, hide camera
            document.getElementById('captureCamera').classList.add('hidden');
            document.getElementById('capturePreview').classList.remove('hidden');
            document.getElementById('captureControls').classList.add('hidden');
            document.getElementById('editControls').classList.remove('hidden');
            document.getElementById('toleranceRow').classList.remove('hidden');

            // Run initial background removal
            removeBackground();

            updateStatus('capture', 'Drag slider to adjust cutout');
        }

        function retakePhoto() {
            originalImageData = null;
            startCaptureCamera();
        }

        // Cached paper color (computed once when photo taken)
        let paperColor = null;

        function analyzePaper() {
            const width = originalImageData.width;
            const height = originalImageData.height;
            const srcData = originalImageData.data;

            // Sample ALL edge pixels
            let avgR = 0, avgG = 0, avgB = 0;
            let count = 0;

            // Top and bottom rows
            for (let x = 0; x < width; x++) {
                let idx = x * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = ((height - 1) * width + x) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }
            // Left and right columns
            for (let y = 1; y < height - 1; y++) {
                let idx = (y * width) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = (y * width + width - 1) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }

            paperColor = {
                r: Math.round(avgR / count),
                g: Math.round(avgG / count),
                b: Math.round(avgB / count)
            };
        }

        function removeBackground() {
            if (!originalImageData || !paperColor) return;

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const width = originalImageData.width;
            const height = originalImageData.height;

            // Do flood fill
            const result = doFloodFillWithTolerance(
                originalImageData.data, width, height,
                paperColor.r, paperColor.g, paperColor.b, tolerance
            );

            const data = result.imageData.data;

            // Sort blobs by size and keep only the biggest
            const sortedBlobs = result.blobs.slice().sort((a, b) => b.size - a.size);
            const biggestBlob = sortedBlobs[0];

            // Remove all blobs except the biggest
            let removed = 0;
            result.blobs.forEach(blob => {
                if (blob !== biggestBlob) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0;
                    });
                    removed++;
                }
            });

            previewCtx.putImageData(result.imageData, 0, 0);
            document.getElementById('saveMaskBtn').classList.remove('hidden');

            const blobSize = biggestBlob ? biggestBlob.size : 0;
            updateStatus('capture', `Kept largest blob (${blobSize} pixels), removed ${removed} others. Tap inside to cut holes.`);
        }

        function cutHoleAtPoint(canvasX, canvasY) {
            if (!previewCanvas || !previewCtx) return;

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const imageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            const data = imageData.data;
            const width = previewCanvas.width;
            const height = previewCanvas.height;

            const startIdx = Math.floor(canvasY) * width + Math.floor(canvasX);
            if (startIdx < 0 || startIdx >= width * height) return;

            // Get the color at tap point
            const tapR = data[startIdx * 4];
            const tapG = data[startIdx * 4 + 1];
            const tapB = data[startIdx * 4 + 2];
            const tapA = data[startIdx * 4 + 3];

            if (tapA === 0) {
                updateStatus('capture', 'Tap on a visible area to cut a hole');
                return;
            }

            // Flood fill from tap point, only filling pixels similar to tapped color
            const visited = new Uint8Array(width * height);
            const queue = [startIdx];
            let head = 0;
            let filledCount = 0;

            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                // Skip transparent pixels
                if (data[idx * 4 + 3] === 0) continue;

                // Check color similarity to tapped color
                const r = data[idx * 4];
                const g = data[idx * 4 + 1];
                const b = data[idx * 4 + 2];

                if (colorDistance(r, g, b, tapR, tapG, tapB) > tolerance) continue;

                // Make transparent
                data[idx * 4 + 3] = 0;
                filledCount++;

                const x = idx % width;
                const y = Math.floor(idx / width);

                // Add neighbors
                if (x > 0) queue.push(idx - 1);
                if (x < width - 1) queue.push(idx + 1);
                if (y > 0) queue.push(idx - width);
                if (y < height - 1) queue.push(idx + width);
            }

            previewCtx.putImageData(imageData, 0, 0);
            updateStatus('capture', `Cut hole (${filledCount} pixels). Tap again or Save.`);
        }

        function doFloodFillWithTolerance(srcData, width, height, avgR, avgG, avgB, tolerance) {
            const imageData = new ImageData(
                new Uint8ClampedArray(srcData),
                width,
                height
            );
            const data = imageData.data;

            const visited = new Uint8Array(width * height);
            const queue = [];
            let head = 0;

            // Add all edge pixels to queue
            for (let x = 0; x < width; x++) {
                queue.push(x);
                queue.push((height - 1) * width + x);
            }
            for (let y = 1; y < height - 1; y++) {
                queue.push(y * width);
                queue.push(y * width + width - 1);
            }

            // Flood fill
            let removedCount = 0;
            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                const x = idx % width;
                const y = Math.floor(idx / width);

                const pixelIdx = idx * 4;
                const r = data[pixelIdx];
                const g = data[pixelIdx + 1];
                const b = data[pixelIdx + 2];

                if (colorDistance(r, g, b, avgR, avgG, avgB) <= tolerance) {
                    data[pixelIdx + 3] = 0;
                    removedCount++;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }
            }

            const opaqueCount = (width * height) - removedCount;

            // Count connected blobs of opaque pixels
            const blobInfo = countBlobs(data, width, height);

            return { imageData, opaqueCount, removedCount, blobCount: blobInfo.count, blobs: blobInfo.blobs };
        }

        function countBlobs(data, width, height) {
            const visited = new Uint8Array(width * height);
            const blobMap = new Int32Array(width * height); // Which blob each pixel belongs to (-1 = none)
            blobMap.fill(-1);
            const blobs = [];
            let blobCount = 0;

            // Colors for visualizing blobs
            const blobColors = [
                [255, 0, 0],     // red
                [0, 255, 0],     // green
                [0, 0, 255],     // blue
                [255, 255, 0],   // yellow
                [255, 0, 255],   // magenta
                [0, 255, 255],   // cyan
                [255, 128, 0],   // orange
                [128, 0, 255],   // purple
                [0, 255, 128],   // spring green
                [255, 0, 128],   // pink
            ];

            for (let startIdx = 0; startIdx < width * height; startIdx++) {
                if (visited[startIdx]) continue;
                if (data[startIdx * 4 + 3] === 0) {
                    visited[startIdx] = 1;
                    continue;
                }

                // Found a new blob
                const blobId = blobCount;
                blobCount++;
                let blobSize = 0;
                let minX = width, minY = height, maxX = 0, maxY = 0;
                let touchesEdge = false;
                const pixelIndices = [];

                const queue = [startIdx];
                let head = 0;

                while (head < queue.length) {
                    const idx = queue[head++];
                    if (visited[idx]) continue;
                    visited[idx] = 1;

                    if (data[idx * 4 + 3] === 0) continue;

                    blobSize++;
                    blobMap[idx] = blobId;
                    pixelIndices.push(idx);

                    const x = idx % width;
                    const y = Math.floor(idx / width);

                    // Check if touches edge
                    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                        touchesEdge = true;
                    }

                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }

                blobs.push({
                    id: blobId,
                    size: blobSize,
                    touchesEdge,
                    pixelIndices,
                    bounds: { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY },
                    color: blobColors[blobId % blobColors.length]
                });
            }

            // Sort blobs by size (largest first)
            blobs.sort((a, b) => b.size - a.size);

            return { count: blobCount, blobs, blobMap };
        }

        function colorizeBlobs(data, blobs) {
            // Color each blob with its assigned color (for visualization)
            blobs.forEach(blob => {
                const [r, g, b] = blob.color;
                blob.pixelIndices.forEach(idx => {
                    data[idx * 4] = r;
                    data[idx * 4 + 1] = g;
                    data[idx * 4 + 2] = b;
                });
            });
        }

        function removeEdgeBlobs(data, blobs) {
            // Remove any blob that touches the edge
            let removedCount = 0;
            blobs.forEach(blob => {
                if (blob.touchesEdge) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0; // Make transparent
                    });
                    removedCount++;
                }
            });
            return removedCount;
        }

        function sampleBackgroundColor(data, width, height) {
            // Sample from corners
            const samples = [];
            const cornerSize = Math.min(20, Math.floor(width / 10), Math.floor(height / 10));

            // Top-left corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Top-right corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-left corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-right corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Average the samples
            const avg = { r: 0, g: 0, b: 0 };
            samples.forEach(s => {
                avg.r += s.r;
                avg.g += s.g;
                avg.b += s.b;
            });
            avg.r = Math.round(avg.r / samples.length);
            avg.g = Math.round(avg.g / samples.length);
            avg.b = Math.round(avg.b / samples.length);

            return avg;
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            // Simple Euclidean distance in RGB space
            return Math.sqrt(
                Math.pow(r1 - r2, 2) +
                Math.pow(g1 - g2, 2) +
                Math.pow(b1 - b2, 2)
            );
        }

        function saveMask() {
            // Convert canvas to data URL
            const dataUrl = previewCanvas.toDataURL('image/png');

            // For now, just download it
            const link = document.createElement('a');
            link.download = 'mask-' + Date.now() + '.png';
            link.href = dataUrl;
            link.click();

            updateStatus('capture', 'Mask saved! You can now use it in Face Track mode.');
        }

        // Tolerance slider - live update as you drag
        document.getElementById('toleranceSlider').addEventListener('input', (e) => {
            document.getElementById('toleranceValue').textContent = e.target.value;
            if (originalImageData && paperColor) {
                removeBackground();
            }
        });

        // ============================================
        // UI HELPERS
        // ============================================

        function updateStatus(view, message) {
            document.getElementById(view + 'Status').textContent = message;
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text || 'Loading...';
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        document.getElementById('startBtn').addEventListener('click', () => {
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        });

        document.getElementById('takePhotoBtn').addEventListener('click', takePhoto);
        document.getElementById('retakeBtn').addEventListener('click', retakePhoto);
        document.getElementById('saveMaskBtn').addEventListener('click', saveMask);

        // Tap on preview canvas to cut holes
        document.getElementById('previewCanvas').addEventListener('click', (e) => {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();

            // Convert click position to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            cutHoleAtPoint(canvasX, canvasY);
        });

        window.addEventListener('resize', () => {
            if (trackCanvas && isTracking) resizeTrackCanvas();
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        window.addEventListener('load', async () => {
            document.getElementById('startBtn').disabled = true;
            showLoading('Loading face detection...');

            try {
                await initializeFaceLandmarker();
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('track', 'Error loading: ' + error.message);
                hideLoading();
            }
        });
    </script>
</body>
</html>
