<!DOCTYPE html>
<!-- Version 2.0 - Added eye anchor points feature -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Face Mask Creator v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: white;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100%;
            max-width: 500px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Tab navigation */
        .tabs {
            display: flex;
            background: #0f0f1a;
        }

        .tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: #16213e;
            border: none;
            color: #888;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab.active {
            background: #e94560;
            color: white;
        }

        /* View containers */
        .view {
            display: none;
            flex-direction: column;
            flex: 1;
        }

        .view.active {
            display: flex;
        }

        .camera-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            overflow: hidden;
            background: #000;
        }

        #video, #captureVideo {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #video {
            transform: scaleX(-1);
            -webkit-transform: scaleX(-1);
        }

        #debugCanvas, #captureCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #previewCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            cursor: crosshair;
        }

        /* Checkerboard background for transparency preview */
        .transparency-bg {
            background-image:
                linear-gradient(45deg, #444 25%, transparent 25%),
                linear-gradient(-45deg, #444 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #444 75%),
                linear-gradient(-45deg, transparent 75%, #444 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            background-color: #333;
        }

        .controls {
            padding: 12px;
            background: #16213e;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .control-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 20px;
            background: #0f3460;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            background: #e94560;
        }

        .control-btn.primary {
            background: #e94560;
            font-weight: 600;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.success {
            background: #27ae60;
        }

        .status {
            padding: 8px;
            text-align: center;
            font-size: 12px;
            color: #888;
            background: #0f0f1a;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 12px;
            font-size: 14px;
            color: #888;
        }

        /* Slider controls */
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: #0f0f1a;
        }

        .slider-row label {
            font-size: 12px;
            color: #888;
            min-width: 80px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 3px;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #e94560;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-size: 12px;
            color: #e94560;
            min-width: 30px;
            text-align: right;
        }

        /* Preview states */
        .preview-container {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-container img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .hidden {
            display: none !important;
        }

        /* Saved masks gallery */
        .gallery {
            display: flex;
            gap: 8px;
            padding: 8px;
            overflow-x: auto;
            background: #0f0f1a;
        }

        .gallery-item {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            border: 2px solid transparent;
            flex-shrink: 0;
        }

        .gallery-item.selected {
            border-color: #e94560;
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Points info bar */
        .points-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #1a3a5c;
            border-top: 1px solid #0f3460;
        }

        .points-info span {
            font-size: 12px;
            color: #aaa;
        }

        .control-btn.small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .control-btn.warning {
            background: #e67e22;
        }

        .version-tag {
            position: fixed;
            bottom: 5px;
            right: 5px;
            font-size: 10px;
            color: #555;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="version-tag">v2.3</div>
    <div class="container">
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" data-view="track">Face Track</button>
            <button class="tab" data-view="capture">Create Mask</button>
        </div>

        <!-- Face Tracking View -->
        <div class="view active" id="trackView">
            <div class="camera-container">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="debugCanvas"></canvas>
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text" id="loadingText">Initializing...</div>
                </div>
            </div>
            <div class="controls">
                <button class="control-btn primary" id="startBtn">Start Camera</button>
                <label class="control-btn" id="loadMaskLabel">
                    Load Mask
                    <input type="file" id="loadMaskInput" accept=".json" style="display:none">
                </label>
                <button class="control-btn" id="clearMaskBtn" style="display:none">Clear Mask</button>
            </div>
            <div class="status" id="trackStatus">Ready - Tap "Start Camera" to begin</div>
        </div>

        <!-- Capture/Create Mask View -->
        <div class="view" id="captureView">
            <!-- Camera state -->
            <div id="captureCamera" class="camera-container">
                <video id="captureVideo" autoplay playsinline muted></video>
            </div>

            <!-- Preview state (after photo taken) -->
            <div id="capturePreview" class="preview-container transparency-bg hidden">
                <canvas id="previewCanvas"></canvas>
            </div>

            <div class="slider-row" id="toleranceRow">
                <label>Tolerance:</label>
                <input type="range" id="toleranceSlider" min="10" max="150" value="60">
                <span class="slider-value" id="toleranceValue">60</span>
            </div>

            <div class="controls" id="captureControls">
                <button class="control-btn primary" id="takePhotoBtn">Take Photo</button>
            </div>

            <div class="controls hidden" id="editControls">
                <button class="control-btn" id="retakeBtn">Retake</button>
                <button class="control-btn" id="addPointsBtn">Add Eye Points</button>
                <button class="control-btn success" id="saveMaskBtn">Save Mask</button>
            </div>

            <div class="points-info hidden" id="pointsInfo">
                <span id="pointsStatus">Tap to place left eye, then right eye</span>
                <button class="control-btn small" id="clearPointsBtn">Clear Points</button>
            </div>

            <div class="status" id="captureStatus">Point camera at your drawing and tap "Take Photo"</div>
        </div>
    </div>

    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/+esm';

        // ============================================
        // LANDMARK INDICES
        // ============================================

        const LEFT_EYE_CENTER = 468;
        const RIGHT_EYE_CENTER = 473;
        const LEFT_EYE_INNER = 133;
        const LEFT_EYE_OUTER = 33;
        const RIGHT_EYE_INNER = 362;
        const RIGHT_EYE_OUTER = 263;
        const MOUTH_LEFT = 61;
        const MOUTH_RIGHT = 291;
        const UPPER_LIP_TOP = 13;
        const LOWER_LIP_BOTTOM = 14;
        const FACE_OVAL = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
            397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150, 136,
            172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109
        ];
        const LEFT_EAR_TOP = 127;
        const LEFT_EAR_BOTTOM = 234;
        const RIGHT_EAR_TOP = 356;
        const RIGHT_EAR_BOTTOM = 454;

        // ============================================
        // STATE
        // ============================================

        let faceLandmarker = null;
        let trackVideo = null;
        let trackCanvas = null;
        let trackCtx = null;
        let isTracking = false;
        let trackAnimationId = null;

        let captureVideo = null;
        let captureStream = null;
        let previewCanvas = null;
        let previewCtx = null;
        let originalImageData = null;
        let currentView = 'track';

        // Saved masks
        const savedMasks = [];

        // Eye point placement state
        let eyePointMode = false;
        let eyePoints = { left: null, right: null };

        // Current mask state (after background removal and hole cuts)
        let currentMaskData = null;

        // Loaded mask for face tracking
        let loadedMask = null;  // { image: HTMLImageElement, anchors: { leftEye, rightEye } }
        let maskImage = null;

        // ============================================
        // TAB NAVIGATION
        // ============================================

        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const viewId = tab.dataset.view;
                switchView(viewId);
            });
        });

        function switchView(viewId) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-view="${viewId}"]`).classList.add('active');

            // Update views
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId + 'View').classList.add('active');

            currentView = viewId;

            // Handle camera switching
            if (viewId === 'capture') {
                stopTracking();
                startCaptureCamera();
            } else {
                stopCaptureCamera();
            }
        }

        // ============================================
        // FACE TRACKING (same as before)
        // ============================================

        async function initializeFaceLandmarker() {
            updateStatus('track', 'Loading face detection model...');

            const filesetResolver = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
            );

            faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numFaces: 1,
                minFaceDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5,
                outputFaceBlendshapes: false,
                outputFacialTransformationMatrixes: false
            });

            updateStatus('track', 'Model loaded - Ready to start');
            document.getElementById('startBtn').disabled = false;
            hideLoading();
        }

        async function startTracking() {
            try {
                updateStatus('track', 'Requesting camera access...');
                showLoading('Accessing camera...');

                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: false
                });

                trackVideo = document.getElementById('video');
                trackVideo.srcObject = stream;
                await new Promise(r => trackVideo.onloadedmetadata = r);
                await trackVideo.play();

                trackCanvas = document.getElementById('debugCanvas');
                trackCtx = trackCanvas.getContext('2d');
                resizeTrackCanvas();

                hideLoading();
                isTracking = true;
                document.getElementById('startBtn').textContent = 'Stop Camera';
                document.getElementById('startBtn').classList.add('active');
                updateStatus('track', 'Face tracking active');

                detectFaces();
            } catch (error) {
                console.error('Camera error:', error);
                updateStatus('track', 'Camera error: ' + error.message);
                hideLoading();
            }
        }

        function stopTracking() {
            isTracking = false;
            if (trackAnimationId) {
                cancelAnimationFrame(trackAnimationId);
                trackAnimationId = null;
            }
            if (trackVideo && trackVideo.srcObject) {
                trackVideo.srcObject.getTracks().forEach(t => t.stop());
                trackVideo.srcObject = null;
            }
            if (trackCtx) {
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);
            }
            document.getElementById('startBtn').textContent = 'Start Camera';
            document.getElementById('startBtn').classList.remove('active');
            updateStatus('track', 'Camera stopped');
        }

        function resizeTrackCanvas() {
            const container = trackCanvas.parentElement;
            const rect = container.getBoundingClientRect();
            trackCanvas.width = rect.width;
            trackCanvas.height = rect.height;
        }

        function detectFaces() {
            if (!isTracking || !faceLandmarker || !trackVideo) return;

            try {
                const results = faceLandmarker.detectForVideo(trackVideo, performance.now());
                trackCtx.clearRect(0, 0, trackCanvas.width, trackCanvas.height);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];

                    // Draw mask first (behind debug overlay)
                    if (loadedMask && maskImage) {
                        drawMaskOverlay(landmarks);
                    }

                    // Draw debug overlay on top (can be toggled off later)
                    drawDebugOverlay(landmarks);
                }
            } catch (error) {
                console.error('Detection error:', error);
            }

            trackAnimationId = requestAnimationFrame(detectFaces);
        }

        function drawDebugOverlay(landmarks) {
            const w = trackCanvas.width;
            const h = trackCanvas.height;
            const toCanvas = (idx) => ({
                x: (1 - landmarks[idx].x) * w,
                y: landmarks[idx].y * h
            });

            // Face oval
            trackCtx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
            trackCtx.lineWidth = 2;
            trackCtx.beginPath();
            const first = toCanvas(FACE_OVAL[0]);
            trackCtx.moveTo(first.x, first.y);
            for (let i = 1; i < FACE_OVAL.length; i++) {
                const pt = toCanvas(FACE_OVAL[i]);
                trackCtx.lineTo(pt.x, pt.y);
            }
            trackCtx.closePath();
            trackCtx.stroke();

            // Eyes
            trackCtx.fillStyle = '#00ff00';
            [LEFT_EYE_CENTER, RIGHT_EYE_CENTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
                trackCtx.fill();
            });

            trackCtx.fillStyle = '#ffff00';
            [LEFT_EYE_INNER, LEFT_EYE_OUTER, RIGHT_EYE_INNER, RIGHT_EYE_OUTER].forEach(idx => {
                const pt = toCanvas(idx);
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Mouth
            const mL = toCanvas(MOUTH_LEFT);
            const mR = toCanvas(MOUTH_RIGHT);
            trackCtx.strokeStyle = '#ff00ff';
            trackCtx.lineWidth = 3;
            trackCtx.beginPath();
            trackCtx.moveTo(mL.x, mL.y);
            trackCtx.lineTo(mR.x, mR.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ff00ff';
            [mL, mR].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            const uL = toCanvas(UPPER_LIP_TOP);
            const lL = toCanvas(LOWER_LIP_BOTTOM);
            trackCtx.fillStyle = '#ff6600';
            [uL, lL].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });

            // Ears
            trackCtx.strokeStyle = '#ffff00';
            trackCtx.lineWidth = 3;
            const leT = toCanvas(LEFT_EAR_TOP);
            const leB = toCanvas(LEFT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(leT.x, leT.y);
            trackCtx.lineTo(leB.x, leB.y);
            trackCtx.stroke();

            const reT = toCanvas(RIGHT_EAR_TOP);
            const reB = toCanvas(RIGHT_EAR_BOTTOM);
            trackCtx.beginPath();
            trackCtx.moveTo(reT.x, reT.y);
            trackCtx.lineTo(reB.x, reB.y);
            trackCtx.stroke();

            trackCtx.fillStyle = '#ffff00';
            [leT, leB, reT, reB].forEach(pt => {
                trackCtx.beginPath();
                trackCtx.arc(pt.x, pt.y, 4, 0, Math.PI * 2);
                trackCtx.fill();
            });
        }

        function drawMaskOverlay(landmarks) {
            if (!loadedMask || !maskImage) return;

            const w = trackCanvas.width;
            const h = trackCanvas.height;

            // Get detected eye positions (mirrored for selfie view)
            const leftEye = {
                x: (1 - landmarks[LEFT_EYE_CENTER].x) * w,
                y: landmarks[LEFT_EYE_CENTER].y * h
            };
            const rightEye = {
                x: (1 - landmarks[RIGHT_EYE_CENTER].x) * w,
                y: landmarks[RIGHT_EYE_CENTER].y * h
            };

            // Get mask anchor points (in pixel coordinates)
            const maskLeftEye = {
                x: loadedMask.anchors.leftEye.x * loadedMask.width,
                y: loadedMask.anchors.leftEye.y * loadedMask.height
            };
            const maskRightEye = {
                x: loadedMask.anchors.rightEye.x * loadedMask.width,
                y: loadedMask.anchors.rightEye.y * loadedMask.height
            };

            // Calculate distances between eyes
            const faceEyeDist = Math.sqrt(
                Math.pow(rightEye.x - leftEye.x, 2) +
                Math.pow(rightEye.y - leftEye.y, 2)
            );
            const maskEyeDist = Math.sqrt(
                Math.pow(maskRightEye.x - maskLeftEye.x, 2) +
                Math.pow(maskRightEye.y - maskLeftEye.y, 2)
            );

            // Calculate scale
            const scale = faceEyeDist / maskEyeDist;

            // Calculate rotation angles
            const faceAngle = Math.atan2(
                rightEye.y - leftEye.y,
                rightEye.x - leftEye.x
            );
            const maskAngle = Math.atan2(
                maskRightEye.y - maskLeftEye.y,
                maskRightEye.x - maskLeftEye.x
            );
            const rotation = faceAngle - maskAngle;

            // Calculate center points
            const faceCenterX = (leftEye.x + rightEye.x) / 2;
            const faceCenterY = (leftEye.y + rightEye.y) / 2;
            const maskCenterX = (maskLeftEye.x + maskRightEye.x) / 2;
            const maskCenterY = (maskLeftEye.y + maskRightEye.y) / 2;

            // Draw the mask with transformation
            trackCtx.save();

            // Move to face center
            trackCtx.translate(faceCenterX, faceCenterY);

            // Rotate to match face angle
            trackCtx.rotate(rotation);

            // Scale to match face size
            trackCtx.scale(scale, scale);

            // Draw image centered on mask's eye center
            trackCtx.drawImage(
                maskImage,
                -maskCenterX,
                -maskCenterY,
                loadedMask.width,
                loadedMask.height
            );

            trackCtx.restore();
        }

        async function loadMaskFile(file) {
            try {
                const text = await file.text();
                const data = JSON.parse(text);

                if (!data.image || !data.anchors || !data.anchors.leftEye || !data.anchors.rightEye) {
                    updateStatus('track', 'Invalid mask file - missing eye anchors');
                    return;
                }

                // Load the image
                const img = new Image();
                img.onload = () => {
                    maskImage = img;
                    loadedMask = {
                        width: data.width,
                        height: data.height,
                        anchors: data.anchors
                    };
                    document.getElementById('clearMaskBtn').style.display = 'inline-block';
                    updateStatus('track', 'Mask loaded! Start camera to see it on your face.');
                };
                img.onerror = () => {
                    updateStatus('track', 'Error loading mask image');
                };
                img.src = data.image;

            } catch (error) {
                console.error('Error loading mask:', error);
                updateStatus('track', 'Error loading mask file');
            }
        }

        function clearLoadedMask() {
            loadedMask = null;
            maskImage = null;
            document.getElementById('clearMaskBtn').style.display = 'none';
            updateStatus('track', 'Mask cleared');
        }

        // ============================================
        // CAPTURE / CREATE MASK
        // ============================================

        async function startCaptureCamera() {
            try {
                updateStatus('capture', 'Starting camera...');

                captureStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1920 }, height: { ideal: 1080 } },
                    audio: false
                });

                captureVideo = document.getElementById('captureVideo');
                captureVideo.srcObject = captureStream;
                await new Promise(r => captureVideo.onloadedmetadata = r);
                await captureVideo.play();

                // Show camera, hide preview
                document.getElementById('captureCamera').classList.remove('hidden');
                document.getElementById('capturePreview').classList.add('hidden');
                document.getElementById('captureControls').classList.remove('hidden');
                document.getElementById('editControls').classList.add('hidden');
                document.getElementById('toleranceRow').classList.add('hidden');

                updateStatus('capture', 'Point camera at your drawing and tap "Take Photo"');
            } catch (error) {
                console.error('Capture camera error:', error);
                updateStatus('capture', 'Camera error: ' + error.message);
            }
        }

        function stopCaptureCamera() {
            if (captureStream) {
                captureStream.getTracks().forEach(t => t.stop());
                captureStream = null;
            }
            if (captureVideo) {
                captureVideo.srcObject = null;
            }
        }

        function takePhoto() {
            if (!captureVideo) return;

            previewCanvas = document.getElementById('previewCanvas');
            previewCtx = previewCanvas.getContext('2d', { willReadFrequently: true });

            // Set canvas to video dimensions
            previewCanvas.width = captureVideo.videoWidth;
            previewCanvas.height = captureVideo.videoHeight;

            // Draw video frame to canvas
            previewCtx.drawImage(captureVideo, 0, 0);

            // Store original image data
            originalImageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            // Analyze paper color from edges
            analyzePaper();

            // Stop camera
            stopCaptureCamera();

            // Show preview, hide camera
            document.getElementById('captureCamera').classList.add('hidden');
            document.getElementById('capturePreview').classList.remove('hidden');
            document.getElementById('captureControls').classList.add('hidden');
            document.getElementById('editControls').classList.remove('hidden');
            document.getElementById('toleranceRow').classList.remove('hidden');

            // Run initial background removal
            removeBackground();

            updateStatus('capture', 'Drag slider to adjust cutout');
        }

        function retakePhoto() {
            originalImageData = null;
            currentMaskData = null;
            eyePoints = { left: null, right: null };
            eyePointMode = false;
            document.getElementById('pointsInfo').classList.add('hidden');
            document.getElementById('addPointsBtn').classList.remove('active');
            startCaptureCamera();
        }

        // Cached paper color (computed once when photo taken)
        let paperColor = null;

        function analyzePaper() {
            const width = originalImageData.width;
            const height = originalImageData.height;
            const srcData = originalImageData.data;

            // Sample ALL edge pixels
            let avgR = 0, avgG = 0, avgB = 0;
            let count = 0;

            // Top and bottom rows
            for (let x = 0; x < width; x++) {
                let idx = x * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = ((height - 1) * width + x) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }
            // Left and right columns
            for (let y = 1; y < height - 1; y++) {
                let idx = (y * width) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
                idx = (y * width + width - 1) * 4;
                avgR += srcData[idx]; avgG += srcData[idx + 1]; avgB += srcData[idx + 2]; count++;
            }

            paperColor = {
                r: Math.round(avgR / count),
                g: Math.round(avgG / count),
                b: Math.round(avgB / count)
            };
        }

        function removeBackground() {
            if (!originalImageData || !paperColor) return;

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const width = originalImageData.width;
            const height = originalImageData.height;

            // Do flood fill
            const result = doFloodFillWithTolerance(
                originalImageData.data, width, height,
                paperColor.r, paperColor.g, paperColor.b, tolerance
            );

            const data = result.imageData.data;

            // Sort blobs by size and keep only the biggest
            const sortedBlobs = result.blobs.slice().sort((a, b) => b.size - a.size);
            const biggestBlob = sortedBlobs[0];

            // Remove all blobs except the biggest
            let removed = 0;
            result.blobs.forEach(blob => {
                if (blob !== biggestBlob) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0;
                    });
                    removed++;
                }
            });

            previewCtx.putImageData(result.imageData, 0, 0);
            document.getElementById('saveMaskBtn').classList.remove('hidden');

            // Save current state for later use (eye point markers)
            currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            const blobSize = biggestBlob ? biggestBlob.size : 0;
            updateStatus('capture', `Kept largest blob (${blobSize} pixels), removed ${removed} others. Tap inside to cut holes.`);
        }

        function cutHoleAtPoint(canvasX, canvasY) {
            if (!previewCanvas || !previewCtx) return;

            const tolerance = parseInt(document.getElementById('toleranceSlider').value);
            const imageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            const data = imageData.data;
            const width = previewCanvas.width;
            const height = previewCanvas.height;

            const startIdx = Math.floor(canvasY) * width + Math.floor(canvasX);
            if (startIdx < 0 || startIdx >= width * height) return;

            // Get the color at tap point
            const tapR = data[startIdx * 4];
            const tapG = data[startIdx * 4 + 1];
            const tapB = data[startIdx * 4 + 2];
            const tapA = data[startIdx * 4 + 3];

            if (tapA === 0) {
                updateStatus('capture', 'Tap on a visible area to cut a hole');
                return;
            }

            // Flood fill from tap point, only filling pixels similar to tapped color
            const visited = new Uint8Array(width * height);
            const queue = [startIdx];
            let head = 0;
            let filledCount = 0;

            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                // Skip transparent pixels
                if (data[idx * 4 + 3] === 0) continue;

                // Check color similarity to tapped color
                const r = data[idx * 4];
                const g = data[idx * 4 + 1];
                const b = data[idx * 4 + 2];

                if (colorDistance(r, g, b, tapR, tapG, tapB) > tolerance) continue;

                // Make transparent
                data[idx * 4 + 3] = 0;
                filledCount++;

                const x = idx % width;
                const y = Math.floor(idx / width);

                // Add neighbors
                if (x > 0) queue.push(idx - 1);
                if (x < width - 1) queue.push(idx + 1);
                if (y > 0) queue.push(idx - width);
                if (y < height - 1) queue.push(idx + width);
            }

            previewCtx.putImageData(imageData, 0, 0);

            // Save current state for later use (eye point markers)
            currentMaskData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);

            updateStatus('capture', `Cut hole (${filledCount} pixels). Tap again or Save.`);
        }

        function doFloodFillWithTolerance(srcData, width, height, avgR, avgG, avgB, tolerance) {
            const imageData = new ImageData(
                new Uint8ClampedArray(srcData),
                width,
                height
            );
            const data = imageData.data;

            const visited = new Uint8Array(width * height);
            const queue = [];
            let head = 0;

            // Add all edge pixels to queue
            for (let x = 0; x < width; x++) {
                queue.push(x);
                queue.push((height - 1) * width + x);
            }
            for (let y = 1; y < height - 1; y++) {
                queue.push(y * width);
                queue.push(y * width + width - 1);
            }

            // Flood fill
            let removedCount = 0;
            while (head < queue.length) {
                const idx = queue[head++];
                if (visited[idx]) continue;
                visited[idx] = 1;

                const x = idx % width;
                const y = Math.floor(idx / width);

                const pixelIdx = idx * 4;
                const r = data[pixelIdx];
                const g = data[pixelIdx + 1];
                const b = data[pixelIdx + 2];

                if (colorDistance(r, g, b, avgR, avgG, avgB) <= tolerance) {
                    data[pixelIdx + 3] = 0;
                    removedCount++;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }
            }

            const opaqueCount = (width * height) - removedCount;

            // Count connected blobs of opaque pixels
            const blobInfo = countBlobs(data, width, height);

            return { imageData, opaqueCount, removedCount, blobCount: blobInfo.count, blobs: blobInfo.blobs };
        }

        function countBlobs(data, width, height) {
            const visited = new Uint8Array(width * height);
            const blobMap = new Int32Array(width * height); // Which blob each pixel belongs to (-1 = none)
            blobMap.fill(-1);
            const blobs = [];
            let blobCount = 0;

            // Colors for visualizing blobs
            const blobColors = [
                [255, 0, 0],     // red
                [0, 255, 0],     // green
                [0, 0, 255],     // blue
                [255, 255, 0],   // yellow
                [255, 0, 255],   // magenta
                [0, 255, 255],   // cyan
                [255, 128, 0],   // orange
                [128, 0, 255],   // purple
                [0, 255, 128],   // spring green
                [255, 0, 128],   // pink
            ];

            for (let startIdx = 0; startIdx < width * height; startIdx++) {
                if (visited[startIdx]) continue;
                if (data[startIdx * 4 + 3] === 0) {
                    visited[startIdx] = 1;
                    continue;
                }

                // Found a new blob
                const blobId = blobCount;
                blobCount++;
                let blobSize = 0;
                let minX = width, minY = height, maxX = 0, maxY = 0;
                let touchesEdge = false;
                const pixelIndices = [];

                const queue = [startIdx];
                let head = 0;

                while (head < queue.length) {
                    const idx = queue[head++];
                    if (visited[idx]) continue;
                    visited[idx] = 1;

                    if (data[idx * 4 + 3] === 0) continue;

                    blobSize++;
                    blobMap[idx] = blobId;
                    pixelIndices.push(idx);

                    const x = idx % width;
                    const y = Math.floor(idx / width);

                    // Check if touches edge
                    if (x === 0 || x === width - 1 || y === 0 || y === height - 1) {
                        touchesEdge = true;
                    }

                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;

                    if (x > 0 && !visited[idx - 1]) queue.push(idx - 1);
                    if (x < width - 1 && !visited[idx + 1]) queue.push(idx + 1);
                    if (y > 0 && !visited[idx - width]) queue.push(idx - width);
                    if (y < height - 1 && !visited[idx + width]) queue.push(idx + width);
                }

                blobs.push({
                    id: blobId,
                    size: blobSize,
                    touchesEdge,
                    pixelIndices,
                    bounds: { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY },
                    color: blobColors[blobId % blobColors.length]
                });
            }

            // Sort blobs by size (largest first)
            blobs.sort((a, b) => b.size - a.size);

            return { count: blobCount, blobs, blobMap };
        }

        function colorizeBlobs(data, blobs) {
            // Color each blob with its assigned color (for visualization)
            blobs.forEach(blob => {
                const [r, g, b] = blob.color;
                blob.pixelIndices.forEach(idx => {
                    data[idx * 4] = r;
                    data[idx * 4 + 1] = g;
                    data[idx * 4 + 2] = b;
                });
            });
        }

        function removeEdgeBlobs(data, blobs) {
            // Remove any blob that touches the edge
            let removedCount = 0;
            blobs.forEach(blob => {
                if (blob.touchesEdge) {
                    blob.pixelIndices.forEach(idx => {
                        data[idx * 4 + 3] = 0; // Make transparent
                    });
                    removedCount++;
                }
            });
            return removedCount;
        }

        function sampleBackgroundColor(data, width, height) {
            // Sample from corners
            const samples = [];
            const cornerSize = Math.min(20, Math.floor(width / 10), Math.floor(height / 10));

            // Top-left corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Top-right corner
            for (let y = 0; y < cornerSize; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-left corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = 0; x < cornerSize; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Bottom-right corner
            for (let y = height - cornerSize; y < height; y++) {
                for (let x = width - cornerSize; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    samples.push({ r: data[idx], g: data[idx + 1], b: data[idx + 2] });
                }
            }

            // Average the samples
            const avg = { r: 0, g: 0, b: 0 };
            samples.forEach(s => {
                avg.r += s.r;
                avg.g += s.g;
                avg.b += s.b;
            });
            avg.r = Math.round(avg.r / samples.length);
            avg.g = Math.round(avg.g / samples.length);
            avg.b = Math.round(avg.b / samples.length);

            return avg;
        }

        function colorDistance(r1, g1, b1, r2, g2, b2) {
            // Simple Euclidean distance in RGB space
            return Math.sqrt(
                Math.pow(r1 - r2, 2) +
                Math.pow(g1 - g2, 2) +
                Math.pow(b1 - b2, 2)
            );
        }

        function saveMask() {
            // Convert canvas to data URL
            const dataUrl = previewCanvas.toDataURL('image/png');

            // Create mask data object with image and anchor points
            const maskData = {
                version: 1,
                image: dataUrl,
                width: previewCanvas.width,
                height: previewCanvas.height,
                anchors: {}
            };

            // Add eye points if they exist (normalized 0-1 coordinates)
            if (eyePoints.left) {
                maskData.anchors.leftEye = {
                    x: eyePoints.left.x / previewCanvas.width,
                    y: eyePoints.left.y / previewCanvas.height
                };
            }
            if (eyePoints.right) {
                maskData.anchors.rightEye = {
                    x: eyePoints.right.x / previewCanvas.width,
                    y: eyePoints.right.y / previewCanvas.height
                };
            }

            // Download as JSON file
            const jsonStr = JSON.stringify(maskData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = 'mask-' + Date.now() + '.json';
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            const hasPoints = eyePoints.left && eyePoints.right;
            updateStatus('capture', hasPoints
                ? 'Mask saved with eye anchor points!'
                : 'Mask saved! (No eye points added)');
        }

        // ============================================
        // EYE POINT PLACEMENT
        // ============================================

        function enterEyePointMode() {
            eyePointMode = true;
            eyePoints = { left: null, right: null };
            document.getElementById('pointsInfo').classList.remove('hidden');
            document.getElementById('addPointsBtn').classList.add('active');
            updatePointsStatus();
            drawEyePointMarkers();
        }

        function exitEyePointMode() {
            eyePointMode = false;
            document.getElementById('pointsInfo').classList.add('hidden');
            document.getElementById('addPointsBtn').classList.remove('active');
        }

        function clearEyePoints() {
            eyePoints = { left: null, right: null };
            updatePointsStatus();
            drawEyePointMarkers();
        }

        function updatePointsStatus() {
            const status = document.getElementById('pointsStatus');
            if (!eyePoints.left) {
                status.textContent = 'Tap to place LEFT eye point';
            } else if (!eyePoints.right) {
                status.textContent = 'Tap to place RIGHT eye point';
            } else {
                status.textContent = 'Both eyes placed! Save or clear to redo.';
            }
        }

        function placeEyePoint(canvasX, canvasY) {
            if (!eyePoints.left) {
                eyePoints.left = { x: canvasX, y: canvasY };
                updatePointsStatus();
                drawEyePointMarkers();
            } else if (!eyePoints.right) {
                eyePoints.right = { x: canvasX, y: canvasY };
                updatePointsStatus();
                drawEyePointMarkers();
            }
            // If both are already placed, do nothing (user must clear first)
        }

        function drawEyePointMarkers() {
            if (!previewCanvas || !previewCtx || !currentMaskData) return;

            // Redraw the current mask state (preserves hole cuts)
            previewCtx.putImageData(currentMaskData, 0, 0);

            // Now draw eye point markers on top
            if (eyePoints.left) {
                drawMarker(eyePoints.left.x, eyePoints.left.y, '#00ff00', 'L');
            }
            if (eyePoints.right) {
                drawMarker(eyePoints.right.x, eyePoints.right.y, '#00ff00', 'R');
            }
        }

        function drawMarker(x, y, color, label) {
            const radius = Math.max(15, previewCanvas.width * 0.02);

            // Outer circle
            previewCtx.strokeStyle = color;
            previewCtx.lineWidth = 3;
            previewCtx.beginPath();
            previewCtx.arc(x, y, radius, 0, Math.PI * 2);
            previewCtx.stroke();

            // Inner dot
            previewCtx.fillStyle = color;
            previewCtx.beginPath();
            previewCtx.arc(x, y, 4, 0, Math.PI * 2);
            previewCtx.fill();

            // Crosshairs
            previewCtx.beginPath();
            previewCtx.moveTo(x - radius - 5, y);
            previewCtx.lineTo(x - radius + 8, y);
            previewCtx.moveTo(x + radius - 8, y);
            previewCtx.lineTo(x + radius + 5, y);
            previewCtx.moveTo(x, y - radius - 5);
            previewCtx.lineTo(x, y - radius + 8);
            previewCtx.moveTo(x, y + radius - 8);
            previewCtx.lineTo(x, y + radius + 5);
            previewCtx.stroke();

            // Label
            previewCtx.font = `bold ${radius}px sans-serif`;
            previewCtx.fillStyle = color;
            previewCtx.textAlign = 'center';
            previewCtx.textBaseline = 'middle';
            previewCtx.fillText(label, x, y + radius + 15);
        }

        // Tolerance slider - live update as you drag
        document.getElementById('toleranceSlider').addEventListener('input', (e) => {
            document.getElementById('toleranceValue').textContent = e.target.value;
            if (originalImageData && paperColor) {
                removeBackground();
                // Redraw eye point markers if any
                if (eyePoints.left) {
                    drawMarker(eyePoints.left.x, eyePoints.left.y, '#00ff00', 'L');
                }
                if (eyePoints.right) {
                    drawMarker(eyePoints.right.x, eyePoints.right.y, '#00ff00', 'R');
                }
            }
        });

        // ============================================
        // UI HELPERS
        // ============================================

        function updateStatus(view, message) {
            document.getElementById(view + 'Status').textContent = message;
        }

        function showLoading(text) {
            document.getElementById('loadingText').textContent = text || 'Loading...';
            document.getElementById('loadingOverlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        document.getElementById('startBtn').addEventListener('click', () => {
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        });

        document.getElementById('loadMaskInput').addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                loadMaskFile(e.target.files[0]);
            }
        });

        document.getElementById('clearMaskBtn').addEventListener('click', clearLoadedMask);

        document.getElementById('takePhotoBtn').addEventListener('click', takePhoto);
        document.getElementById('retakeBtn').addEventListener('click', retakePhoto);
        document.getElementById('saveMaskBtn').addEventListener('click', saveMask);

        // Tap on preview canvas - either cut holes or place eye points
        document.getElementById('previewCanvas').addEventListener('click', (e) => {
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();

            // Convert click position to canvas coordinates
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;

            if (eyePointMode) {
                placeEyePoint(canvasX, canvasY);
            } else {
                cutHoleAtPoint(canvasX, canvasY);
            }
        });

        // Add Eye Points button
        document.getElementById('addPointsBtn').addEventListener('click', () => {
            if (eyePointMode) {
                exitEyePointMode();
            } else {
                enterEyePointMode();
            }
        });

        // Clear Points button
        document.getElementById('clearPointsBtn').addEventListener('click', clearEyePoints);

        window.addEventListener('resize', () => {
            if (trackCanvas && isTracking) resizeTrackCanvas();
        });

        // ============================================
        // INITIALIZATION
        // ============================================

        window.addEventListener('load', async () => {
            document.getElementById('startBtn').disabled = true;
            showLoading('Loading face detection...');

            try {
                await initializeFaceLandmarker();
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('track', 'Error loading: ' + error.message);
                hideLoading();
            }
        });
    </script>
</body>
</html>
